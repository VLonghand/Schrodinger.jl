<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Getting Started · Schrodinger.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/highlightjs/default.css" rel="stylesheet" type="text/css"/><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Schrodinger.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li class="current"><a class="toctext" href="gettingstarted.html">Getting Started</a><ul class="internal"><li><a class="toctext" href="#First-Steps-1">First Steps</a></li><li><a class="toctext" href="#Quantum-States-1">Quantum States</a></li><li><a class="toctext" href="#Operators-1">Operators</a></li><li><a class="toctext" href="#Simple-Dynamics-1">Simple Dynamics</a></li></ul></li><li><a class="toctext" href="quantumobjects.html">Quantum Objects</a></li><li><a class="toctext" href="working.html">Working with States and Operators</a></li><li><a class="toctext" href="dynamics.html">Time Evolution and Dynamics</a></li></ul></li><li><span class="toctext">API</span><ul><li><a class="toctext" href="../api/quobj.html">Quantum Object Types</a></li><li><a class="toctext" href="../api/states.html">State Library</a></li><li><a class="toctext" href="../api/operators.html">Operator Library</a></li><li><a class="toctext" href="../api/functions.html">Function Library</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href="gettingstarted.html">Getting Started</a></li></ul><a class="edit-page" href="https://github.com/jebej/Schrodinger.jl/tree/4d0aeff18f5c71ddddf1cc79701f2d49ed578b9f/docs/src/man/gettingstarted.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Getting Started</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Getting-Started-1" href="#Getting-Started-1">Getting Started</a></h1><h2><a class="nav-anchor" id="First-Steps-1" href="#First-Steps-1">First Steps</a></h2><p>The first step to using Schrodinger.jl is to install it. This is easy to do with Julia&#39;s package manager. Type <code>Pkg.clone(&quot;https://github.com/jebej/Schrodinger.jl.git&quot;)</code> at the Julia <code>REPL</code> to download the package to your computer. From there, the package can be used or imported like any other Julia package:</p><pre><code class="language-julia">using Schrodinger</code></pre><h2><a class="nav-anchor" id="Quantum-States-1" href="#Quantum-States-1">Quantum States</a></h2><p>In quantum mechanics, one of the most fundamental object for describing the <a href="https://en.wikipedia.org/wiki/Quantum_state">state of a system</a> is a state vector. State vectors represent pure quantum states, as opposed to mixed quantum stated, but we will get to that later.</p><p>Schrodinger.jl uses the ubiquitous &quot;<a href="https://en.wikipedia.org/wiki/Bra%E2%80%93ket_notation">bra-ket</a>&quot; formalism to describe pure states. A ket is nothing more than a normal (column) vector, which in linear algebra lingo are elements of a vector space. In quantum mechanics, the vector space within which ket vectors live is called a <a href="https://en.wikipedia.org/wiki/Hilbert_space">Hilbert space</a>.</p><p>Kets (and their dual, bras) are therefore finite-, or infinite-dimensional vectors. To create a ket in Schrodinger.jl, use the <a href="../api/quobj.html#Schrodinger.Ket"><code>Ket</code></a> function with a vector as an argument:</p><pre><code class="language-julia-repl">julia&gt; g = Ket([1,0])
2-d Schrodinger.Ket{Array{Float64,1},1} with space dimensions 2:
1.00∠0°|0⟩</code></pre><p>The output is a bit busy, so let us go through it.</p><p>The input to the <code>Ket</code> function was a 2-d vector <code>[1,0]</code>. This can be seen of the first line of the output, which starts with &quot;2-d&quot;. The next term is the type of the object, which is a <code>Schrodinger</code> (the package name) <code>Ket</code> (the type itself). The <code>Ket</code> type is parameterized by two values, which are seen within the curly brackets and separated by a comma: first, the type of the underlying data, which here is a 1-d <code>Array</code> of <code>Float64</code> values (by default, kets and other objects are stored in the format you give to the constructor, although the elements will be converted to floating point values), and second, the total number of subspaces in the full Hilbert space that the <code>Ket</code> lives in. Here, the number is simply 1. The end of the line states the subspace dimensions, but since we have only 1 subspace with dimension 2, this is not very interesting.</p><p>The second line prints the vector in bra-ket polar notation. Since the vector we passed had the entry &quot;1&quot; in the &quot;zeroth&quot; (which is the first) dimension, the ket we get is simply <span>$|0⟩$</span>.</p><p>Schrodinger.jl only supports finite dimensional Hilbert spaces. If the physical system you want to describe is infinite-dimensional, it will need to be truncated.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>All objects in Schrodinger.jl are expressed in the computational or number basis. This means that the ground state is <span>$|0⟩$</span>, and exited states are numbered starting from 1: <span>$|1⟩, |2⟩, |3⟩...$</span></p></div></div><p>To learn more about quantum states in Schrodinger.jl, including mixed states represented by density matrices, please see the <a href="quantumobjects.html#creating_states-1">next section</a>.</p><h2><a class="nav-anchor" id="Operators-1" href="#Operators-1">Operators</a></h2><p>States are useful, but we need to do something with them. This is what an <a href="../api/quobj.html#Schrodinger.Operator"><code>Operator</code></a> is for. Operators act on elements of a Hilbert space (that is, on kets) to modify them. An operator is thus a like a function that takes as input a ket, and returns a new one. The natural representation for an operator is a matrix, but in Schrodinger.jl you need to use the <code>Operator</code> type, which stores a matrix and other important information about the operator.</p><p>Arbitrary operators can of course be created, but let&#39;s take a look at one that is built-in, the <span>$σ_x$</span> operator:</p><pre><code class="language-julia-repl">julia&gt; σx
2×2 Schrodinger.Operator{SparseMatrixCSC{Float64,Int64},1} with space dimensions 2:
 0.0  1.0
 1.0  0.0</code></pre><p>Notice that the first line of the output is very similar to that of the ket we created above. It lists the dimensions of the matrix, the type and the space dimensions (which again is just a single 2-d space).</p><p>The state <code>g</code> that we created in the previous section is a ground state with the same dimensions. Thus, the <span>$σ_x$</span> operator can act on it! This is done simply by multiplying the two objects, with the operator acting to the right on the ket:</p><pre><code class="language-julia-repl">julia&gt; σx*g
2-d Schrodinger.Ket{Array{Float64,1},1} with space dimensions 2:
1.00∠0°|1⟩</code></pre><p>As expected, the output is a <code>Ket</code>, but notice the state is now <span>$|1⟩$</span>! By acting on the ground state <span>$|0⟩$</span> with the <span>$σ_x$</span> operator, we obtained the excited state. This is because the <span>$σ_x$</span> operator is the &quot;flip&quot; operator. It takes <span>$|0⟩$</span> to <span>$|1⟩$</span>, and <span>$|1⟩$</span> to <span>$|0⟩$</span>. If we apply <span>$σ_x$</span> twice then, we get <span>$|0⟩$</span> back:</p><pre><code class="language-julia-repl">julia&gt; σx*σx*g
2-d Schrodinger.Ket{Array{Float64,1},1} with space dimensions 2:
1.00∠0°|0⟩</code></pre><h2><a class="nav-anchor" id="Simple-Dynamics-1" href="#Simple-Dynamics-1">Simple Dynamics</a></h2><p>Now that we have a state and an operator, we can perform some time dynamics! The <span>$σ_x$</span> operator, in the context of a spin-1/2 system, can represent a transverse magnetic field. In such a situation, a particle starting in the ground state will undergo sinusoidal oscillations between <span>$|0⟩$</span> and <span>$|1⟩$</span> due to the action of the field. Let&#39;s simulate it!</p><p>We first set up the Hamiltonian, assuming our field has an angular frequency <span>$ω=1.0×2π$</span> (i.e. 1 Hz). If we look at a 2 sec timespan, we should thus see 2 full periods. To measure the value of the spin at each instant in time, we choose the <span>$-σ_z$</span> operator as our observable. The minus sign ensures that the <span>$|0⟩$</span> state is the lowest energy one (again, because we are in the computational basis).</p><pre><code class="language-julia">ω = 1.0*2π # angular frequency
H = ω/2*σx # Hamiltonian
t = (0.0,2.0) # timespan
O = -σz # observable
# output
2×2 Schrodinger.Operator{SparseMatrixCSC{Float64,Int64},1} with space dimensions 2:
 -1.0  0.0
  0.0  1.0</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Schrodinger.jl uses units where <span>$ħ$</span> is equal to 1. Make sure that your Hamiltonian is expressed in units of angular frequency, not energy. If you do have a Hamiltonian expressed in energy units, just use the <a href="man/@ref"><code>scale!</code></a> function: <code>scale!(H,1/ħ)</code>. The variable <code>ħ</code> is exported by the module and so can be used as-is.</p></div></div><p>We can now pass all three arguments (<code>H</code>, <code>g</code> and <code>O</code>) to the <a href="man/@ref"><code>sesolve</code></a> function (Schrodinger Equation solver) to solve for the time dynamics! We also pass a keyword argument <code>saveat</code> to make sure we have enough points. As can be seen, the results match with theory:</p><pre><code class="language-julia">res = sesolve(H, g, t, [O], saveat=linspace(0,2,101))
real.(res.evals) ≈ -cos(ω.*res.times) # check against theory
# output
true</code></pre><p>Let&#39;s plot the results!</p><div></div><div><pre><code class="language-julia">using Plots
plot(res.times, real.(res.evals), xlabel=&quot;time (s)&quot;, label=&quot;\$⟨-σ_z⟩\$&quot;)</code></pre></div><p><img src="img/example1-plot.svg" alt="spin-1/2 system oscillations"/></p><p>As we predicted, the system oscillates between -1, the expectation value of <span>$-σ_z$</span> when in the ground state, and 1 when in the excited state.</p><p>This concludes the first section of the manual. Hopefully you now know enough to get started with simple quantum operations. If you would like to learn more about the other features of Schrodinger.jl, keep reading!</p><footer><hr/><a class="previous" href="../index.html"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="quantumobjects.html"><span class="direction">Next</span><span class="title">Quantum Objects</span></a></footer></article></body></html>
